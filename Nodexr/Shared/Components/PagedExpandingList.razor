@typeparam TItem

@using System.Threading
@using Microsoft.AspNetCore.Components.Web.Virtualization

@foreach (var item in items)
{
    @ItemContent(item)
}

<button @onclick="LoadNextItems" disabled="@isLoading" class="btn btn-outline-light mt-3">
    @if (isLoading)
    {
        <div class="spinner-border spinner-border-sm" role="status">
            <span class="sr-only">Loading</span>
        </div>
    }
    else
    {
        @:Load Next
    }
</button>

@code {
    bool isLoading = true;

    /// <summary>
    /// Gets or sets the function providing items to the list.
    /// </summary>
    [Parameter]
    public ItemsProviderDelegate<TItem> ItemsProvider { get; set; }

    [Parameter]
    public RenderFragment<TItem> ItemContent { get; set; }

    [Parameter]
    public int ChunkSize { get; set; } = 25;

    private List<TItem> items = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadNextItems();
    }

    private async Task LoadNextItems()
    {
        isLoading = true;
        var cancellationToken = new CancellationToken(); //Dummy token for ItemsProviderRequest, currently unused.
        var itemsProviderRequest = new ItemsProviderRequest(items.Count, ChunkSize, cancellationToken);
        var newItems = await ItemsProvider(itemsProviderRequest);

        //This check is a cheap workaround to prevent multiple requests being added to the list out of order. Should ideally be implemented with CancellationToken.
        if (isLoading)
        {
            items.AddRange(newItems.Items);
            isLoading = false;
        }
    }

    public async Task RefreshDataAsync()
    {
        items.Clear();
        await LoadNextItems();
    }
}
