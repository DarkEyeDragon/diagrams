@inject INodeHandler NodeHandler
@inject IJSRuntime JSRuntime
@inject IModalService ModalService
@inject NavigationManager NavManager
@inject IToastService ToastService
@inject RegexReplaceHandler RegexReplaceHandler
@using Microsoft.AspNetCore.WebUtilities

<h3 style="margin:6px 10px 7px 7px; display:inline-block;">Output:</h3>

<div class="output-regex-container">
    <div class="output-regex">@if (isEditing)
    {<OutputEditor StartExpression="@NodeHandler.CachedOutput.Expression"
                   OnSubmitted="@OnEditSubmitted"/>}
    else
    {
        @foreach (var segment in @NodeHandler.CachedOutput.Contents)
        {<OutputDisplaySegment Segment="segment" @key="segment"/>@*This must not be surrounded by whitespace*@}
    }
    </div>

    <button title="Copy to clipboard" class="output-regex output-regex-button" @onclick="CopyTextToClipboard"><i class="far fa-clipboard"></i></button>
    <button title="Edit" class="output-regex output-regex-button" @onclick="OnEditButtonClick"><i class="fas fa-pencil-alt"></i></button>
    <button title="Create shareable link" class="output-regex output-regex-button" @onclick="OnCreateLinkButtonClick"><i class="fas fa-link"></i></button>
</div>


@functions{

    bool isEditing = false;

    protected override void OnInitialized()
    {
        NodeHandler.OutputChanged += (sender, e) => StateHasChanged();
    }

    private void OnEditButtonClick()
    {
        isEditing = !isEditing;
    }

    private void OnEditSubmitted(string newExpression)
    {
        isEditing = false;
        Console.WriteLine("Submitted: " + newExpression);
        NodeHandler.TryCreateTreeFromRegex(newExpression);
    }

    @*private async Task OnEditButtonClick()
    {
        var modalParameters = new ModalParameters();
        modalParameters.Add(nameof(EditRegexDialog.previousRegex), NodeHandler.CachedOutput.Expression);

        var modal = ModalService.Show<EditRegexDialog>("Custom Expression", modalParameters);
        var result = await modal.Result;
        if (result.Cancelled)
        {
            Console.WriteLine("Modal was cancelled");
        }
        else if (result.Data is string customRegex)
        {
            Console.WriteLine("Custom Regex: " + customRegex);
            NodeHandler.TryCreateTreeFromRegex(customRegex);
        }
    }*@

    private async Task OnCreateLinkButtonClick()
    {
        var urlParams = new Dictionary<string, string>
        {
            { "parse", NodeHandler.CachedOutput.Expression }
        };

        if (RegexReplaceHandler.SearchText != RegexReplaceHandler.DefaultSearchText)
        {
            urlParams.Add("search", RegexReplaceHandler.SearchText);
        }

        if (RegexReplaceHandler.ReplacementRegex != RegexReplaceHandler.DefaultReplacementRegex)
        {
            urlParams.Add("replace", RegexReplaceHandler.ReplacementRegex);
        }

        string url = QueryHelpers.AddQueryString(NavManager.BaseUri, urlParams);
        await JSRuntime.InvokeVoidAsync("clipboardCopy.copyText", url, "");
        ToastService.ShowInfo("", "Link copied to clipboard");
    }

    private async Task CopyTextToClipboard()
    {
        string regex = NodeHandler.CachedOutput.Expression;
        await JSRuntime.InvokeVoidAsync("clipboardCopy.copyText", regex, "");
        ToastService.ShowInfo(regex, "Copied to clipboard");
    }
}
